// ✅ Binary Search on Answer
int binarySearchAnswer(int low, int high) {
    int ans = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (check(mid)) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}

// ✅ DFS
void dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[node] = true;
    for (int nei : adj[node]) {
        if (!visited[nei]) dfs(nei, adj, visited);
    }
}

// ✅ BFS
void bfs(int start, vector<vector<int>>& adj) {
    queue<int> q;
    vector<bool> visited(adj.size(), false);
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        for (int nei : adj[node]) {
            if (!visited[nei]) {
                visited[nei] = true;
                q.push(nei);
            }
        }
    }
}

// ✅ Two Pointers (Sorted Array)
bool hasPairWithSum(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) return true;
        else if (sum < target) left++;
        else right--;
    }
    return false;
}

// ✅ Prefix Sum
vector<int> buildPrefixSum(vector<int>& a) {
    int n = a.size();
    vector<int> prefix(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefix[i + 1] = prefix[i] + a[i];
    }
    return prefix;
}

// ✅ DP (Memoization)
int dp[1001][1001];
int solve(int i, int j) {
    if (base_case) return ...;
    if (dp[i][j] != -1) return dp[i][j];
    int res = ... // try choices
    return dp[i][j] = res;
}

// ✅ Union Find
vector<int> parent, rank;
void makeSet(int n) {
    parent.resize(n); rank.assign(n, 0);
    for (int i = 0; i < n; ++i) parent[i] = i;
}
int find(int x) {
    if (x != parent[x]) parent[x] = find(parent[x]);
    return parent[x];
}
void unite(int x, int y) {
    x = find(x); y = find(y);
    if (x == y) return;
    if (rank[x] < rank[y]) swap(x, y);
    parent[y] = x;
    if (rank[x] == rank[y]) rank[x]++;
}

// ✅ Kadane's Algorithm
int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0], currSum = nums[0];
    for (int i = 1; i < nums.size(); ++i) {
        currSum = max(nums[i], currSum + nums[i]);
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}

// ✅ Modular Power
int mod_pow(int a, int b, int MOD) {
    int res = 1;
    while (b) {
        if (b & 1) res = (1LL * res * a) % MOD;
        a = (1LL * a * a) % MOD;
        b >>= 1;
    }
    return res;
}

// ✅ Topological Sort (Kahn's Algorithm)
vector<int> topoSort(int V, vector<vector<int>>& adj) {
    vector<int> indegree(V, 0);
    for (auto& u : adj) for (int v : u) indegree[v]++;
    queue<int> q;
    for (int i = 0; i < V; ++i) if (indegree[i] == 0) q.push(i);
    vector<int> topo;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        topo.push_back(node);
        for (int v : adj[node]) {
            if (--indegree[v] == 0) q.push(v);
        }
    }
    return topo;
}
